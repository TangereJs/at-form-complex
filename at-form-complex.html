<link rel="import" href="../tangere/tangere.html">
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="../at-elements/at-designer-elements.html">
<link rel="import" href="../at-core-schema/at-core-schema.html">
<link rel="import" href="../at-form-behaviors/at-form-behaviors-rules-evaluation.html">
<link rel="import" href="../at-i18n/at-i18n-behavior.html">
<link rel="import" href="../at-form-behaviors/at-form-behaviors.html">

<dom-module id="at-form-complex">
  <template>
    <style include="at-form-common"></style>
    <style>
      :host * {
        box-sizing: border-box;
      }

      :host {
        @apply(--at-form-host);
      }

      .form-element {
        min-height: var(--at-form-complex-form-element-min-height, 0);
      }

      .horizontal .form-element {
        min-height: var(--at-form-complex-layout-horizontal-form-element-min-height, 0);
      }

    </style>
    <div id="atContainer" class="at-container">
      <label id="label">{{label}}</label>
      <template is="dom-if" if="{{label}}">
        <hr id="labelHr">
      </template>
      <div id="contentContainer" class="at-content-container">
        <div id="insertPoint"></div>
      </div>
      <div id="hint"></div>
    </div>
  </template>
</dom-module>

<script>
  "use strict";
  Polymer({
    is: 'at-form-complex',
    behaviors: [ Tangere.behaviors.i18n, Tangere.behaviors.RulesEvaluation, Tangere.behaviors.formUIGeneric ],
    properties: {
      /**
       * Textual label for the element
       * @property label
       * @type String
       * @default ''
       */
      label: {
        type: String,
        value: '',
        title: 'Label'
      },
      /**
       * When true hides the label for the element
       * @property hideLabel
       * @type Boolean
       * @default false
       */
      hideLabel: {
        type: Boolean,
        value: false,
        observer: '_hideLabelChanged',
        title: 'Do not show the label'
      },
      /**
       * Specification of elements that should appear on the element.<br/>
       * Provide either an object or string.<br/>
       * List property definitions inside properties object.<br/>
       *
       * @property schema
       * @type Object | Stirng
       * @default { properties: {} }
       */
      schema: {
        type: Object,
        value: function() {
          return {
            properties: {}
          };
        },
        observer: '_schemaChanged',
        title: 'Schema'
      },
      /**
       * Holds values of the elements on the element
       *
       * @property value
       * @type Object | String
       * @default {}
       */
      value: {
        type: Object,
        value: function() {
          return {};
        },
        observer: '_valueChanged',
        title: 'Value'
      },
      /**
       * When true disables all elements on the form
       * @property disabled
       * @type Boolean
       * @default false
       */
      disabled: {
        type: Boolean,
        notify: true,
        value: false,
        observer: '_disabledChanged',
        title: 'Field value can not be changed'
      },
      /**
       * Hides the element. When hidden nothing is displayed for the element
       * @property hide
       * @type Boolean
       * @default false
       */
      hide: {
        type: Boolean,
        value: false,
        observer: '_hideChanged',
        title: 'Field is invisible'
      },

      /**
       * _layout <br>
       * added as support for rendering rows in at-form-array <br>
       * _layout = horizontal lays out elements in a horizontal line <br>
       * _layout = vertical lays out elements in a single vertical column <br>
       * @property _layout
       * @type String
       * @default vertical
       */
      _layout: {
        type: String,
        value: 'vertical',
        observer: '_layoutChanged',
        xtype: 'enum',
        xvaluelist: 'horizontal,vertical'
      }
    },

    observers: [
      '_internalValidStateUpdate(disabled, hide)'
    ],

    $meta: [{
      title: "Object",
      type: "object"
    }],

    _hideLabelChanged: function(newValue, oldValue) {
      this.toggleClass("hidden", newValue, this.$.label);
      var labelHr = this.$$('#labelHr');
      this.toggleClass("hidden", newValue, labelHr);
    },

    ready: function() {
      this._isReady = true;
    },

    _schemaChanged: function(newValue, odlValue) {
      var _sh = window.schemaHelpers;

      if (_sh.isString(newValue)) {
        /*
          if newValue for schema is given as json string, parse it and assign it to this.schema
          if newValue is a valid json string this.schema will trigger _schemaChanged again so we return to prevent schema changes being applied twice
          if newValue is an invalid json string just return. Whatever the previous schema was that remains visible to the user
        */
        try {
          newValue = JSON.parse(newValue);
          this.schema = newValue;
        } catch (e) {
          console.log(e);
        }
        return;
      }

      var hint = this.$.hint;
      var previousHintValue = Polymer.dom(hint).innerHTML;
      // check if newValue is valid schema object
      // if its invalid whatever the previous schema was that remains visible to the user
      if (!_sh.isObject(newValue) || !_sh.isObject(newValue.properties)) {
        Polymer.dom(hint).innerHTML = "Invalid schema. Schema doesn't contain a 'properties' property";
        return;
      } else {
        Polymer.dom(hint).innerHTML = previousHintValue;
      }

      // if value is set before schema, this._internalData is already updated
      // if schema is set first this._internalData is undefined so its initialized to empty object
      if (!this._internalData) {
        this._internalData = {};
      }

      var self = this;

      // calculating valid state for the form is faster if we cache references to each element on the form
      // its even faster if we exclude elements that do not have valid property
      self._elementsToValidate = [];

      if (!_sh.isArray(self._unsupported_types)) {
        // ------------------------------------------------------------
        // unsupported types
        // list type or xtype of the element that should not be supported by at-form-complex
        // ------------------------------------------------------------
        self._unsupported_types = ["object", "array"];
      }

      var fieldsContainer = this.$.insertPoint;

      // clear the previous html content in the container
      // we do not use Polymer.dom(fieldsContainer).innerHTML = "" because innerHTML invokes browser's html parser which is more expensive than removing nodes
      while (Polymer.dom(fieldsContainer).firstChild) {
        Polymer.dom(fieldsContainer).removeChild(Polymer.dom(fieldsContainer).firstChild);
      }

      var fieldsFragment = document.createDocumentFragment();
      var divPrototype = document.createElement('div');
      var propertyNames = Object.keys(newValue.properties);

      var propertyDefinition; // definition of a single property
      var defaultValue; // holds the default value for the element
      var containsProperty; // temporary holds the value from the at-form-complex.value property
      var displayType; // type of the property; translates to a coresponding element
      var fieldContainer; // at-form-complex class="field" wrapper for formElement
      var fieldElement; // holds a reference to a newly created element
      var usexgridCols = false;

      // FIXME: why usexgridCols exists? what is its purpose?
      var propertiesJsonStr = JSON.stringify(newValue.properties);
      usexgridCols = propertiesJsonStr.indexOf("xgridcols") !== -1;
      var insertPoint = this.$.insertPoint;
      if (!usexgridCols) {
        Polymer.dom(insertPoint).classList.add('layout');
      } else {
        Polymer.dom(insertPoint).classList.remove('layout');
      }

        propertyNames.forEach(function(propertyName) {
          propertyDefinition = newValue.properties[propertyName];

          // handle the default value
          defaultValue = propertyDefinition.default;
          containsProperty = self._internalData.hasOwnProperty(propertyName);
          // if default value is defined and _internalData[propertyName] value is undefiend put default value into self._internalData
          if (defaultValue !== undefined && !containsProperty) {
            self._internalData[propertyName] = defaultValue;
          }

          // handle xgridcols
          var xgridcols = displayType === "section" ? 12 : 6;
          if (_sh.isNumber(propertyDefinition.xgridcols)) {
            xgridcols = parseInt(propertyDefinition.xgridcols);
          }

          fieldContainer = divPrototype.cloneNode(true);
          Polymer.dom(fieldContainer).classList.add('form-element');
          var gridColsCssName = "col-" + xgridcols;
          if (!usexgridCols) {
            gridColsCssName = "flex";
          }
          Polymer.dom(fieldContainer).classList.add(gridColsCssName);

          displayType = schemaHelpers.getDisplayType(propertyDefinition, self._unsupported_types);
          fieldElement = schemaHelpers.createElement(propertyName, displayType, propertyDefinition);

          if (!self._internalData.hasOwnProperty(propertyName)) {
            // at-form-complex._internalData doesn't contain an entry for the current property
            // add initial value of the formElement to the at-form-complex.data
            self._internalData[propertyName] = fieldElement.value;
          } else {
            // else set initial value from at-form-complex.data to fromElement
            fieldElement.value = self._internalData[propertyName];
          }

          if (_sh.isFunction(fieldElement.clearUIValidState)) {
            // at-form-section doesn't have clearUIValidState function nor does it need one
            fieldElement.clearUIValidState();
          } else if (_sh.isFunction(fieldElement._clearUIValidState)) {
            fieldElement._clearUIValidState();
          }

          fieldElement.addEventListener('value-changed', function(event) {
            event.stopPropagation();

            var id = event.target.id;
            var newValue = event.detail.value;
            var currentValue = self._internalData[id];
            if (!_sh.areEqual(currentValue, newValue)) {
              self._updateValueObject(id, newValue);
            }
          });

          Polymer.dom(fieldElement).setAttribute('id', propertyName);
          self._elementsToValidate.push(fieldElement);

          // *ij* support for layout
          // if layout === horizontal new elements have hidden labels
          fieldElement.hideLabel = propertyDefinition.hideLabel || self._layout === 'horizontal';

          // if at-form-complex is initially hidden, element should be hidden as well
          fieldElement.hide = self.hide || _sh.parseBool(propertyDefinition.hide);

          // if at-form-complex is initially disabled, element should be disabled as well
          fieldElement.disabled = self.disabled || _sh.parseBool(propertyDefinition.disabled);

          // form-complex passes its value of autovalidate to its contained elements
          // this enables at-core-form to control autovalidate value for elements contained inside form-complex
          fieldElement.autovalidate = self.autovalidate;

          // append paper element to its container
          Polymer.dom(fieldContainer).appendChild(fieldElement);
          // add container to as child to insertPoint
          Polymer.dom(fieldsFragment).appendChild(fieldContainer);
        });

        // if data was set first there is a chance that some properties form this._internalData are missing in this.data
        // this.data must be updated with missing properties
        if (_sh.isObject(self.value)) {
          var internalDataKeys = Object.keys(this._internalData);
          internalDataKeys.forEach(function (key, index) {
            // self.value[key] === undefined means that the key is missing from self.value
            if (!self.value.hasOwnProperty(key)) {
              self.value[key] = self._internalData[key];
            }
          });
        }

        // add div class="clearfix"
        var clearfixDiv = divPrototype.cloneNode(true);
        Polymer.dom(clearfixDiv).classList.add('clearfix');
        Polymer.dom(fieldsFragment).appendChild(clearfixDiv);

        Polymer.dom(fieldsContainer).appendChild(fieldsFragment);

        // if any element is required in schema its valid state is updated after creation
        // at-form-complex needs to reflect that state
        this.validate();
    },

    /* *ij*
     OK. Imperative data binding doesn't work in polymer anymore.
     It may happen in the future but not in near future.
     Using at-form-complex.data[field] = 'newValue' doesn't work. Its not possible to bind to at-form-complex.data[field] to update field value automatically
     Explained in https://github.com/Polymer/polymer/issues/1778 and https://github.com/Polymer/polymer/issues/1796

     So, to solve this shortcoming a updateFormElementValue function is introduced
     The purpose of this function is, obviously, to update a value of the specific field.
     This function will update the .data object and .value of the field with provided elementId.
     If the field with provided elementId doesn't exist a debug message will be loged in the console

     Alternative to this approach is to create a completely new object each time you want to update the .data property
     IMO, this approach is a waste of time. An updateFormElementValue function is much more efficient

     Another alternative to this approach is to have a function that will return the element itself. Than the client can do whatever he likes with the element
     not just update value. This approach seems reasonable for setFieldState action in at-form-rule-edit
     */
    updateFormElementValue: function(elementId, value) {
      var fieldElement = this.getElement(elementId);
      if (!fieldElement) {
        return;
      }

      this.value[elementId] = value;
      fieldElement.value = value;

      // *ij* polymer js doesn't call valueChanged if value is of type array or object
      // we check for this situation and call valueChanged by hand
      if (schemaHelpers.isObject(fieldElement.value) || schemaHelpers.isArray(fieldElement.value)) {
        if (fieldElement.valueChanged) {
          fieldElement.valueChanged(value, undefined);
        } else if (fieldElement._valueChanged) {
          fieldElement._valueChanged(value, undefined);
        }
      }
    },

    setElementState: function(elementId, state, value) {
      var element = this.getElement(elementId);
      if (!element) {
        return;
      }

      element[state] = value;
    },

    getElement: function(elementId) {
      var fieldsContainer = this.$.insertPoint;
      var selector = '#' + elementId;
      var fieldElement = Polymer.dom(fieldsContainer).querySelector(selector);
      return fieldElement;
    },

    _valueChanged: function(newValue, oldValue) {
      var _sh = window.schemaHelpers;

      if (_sh.isString(newValue)) {
        /*
          if newValue for data is given as json string, parse it and assign it to this.data
          if newValue is a valid json string this.data will trigger _dataChanged again so we return to prevent data changes being applied twice
          if newValue is an invalid json string just return. Whatever the previous data was that remains visible to the user
        */
        try {
          newValue = JSON.parse(newValue);
          this.value = newValue;
        } catch (e) {
          console.log(e);
        }
        return;
      }

      // if new value is not an object, ignore the value and return
      if (!_sh.isObject(newValue)) {
        console.log('at-form-complex expects objects as new value, but got ' + _sh.formatJson(newValue) + ' instead');
        return;
      }

      // initalize _internalData object; this objects holds last valid data set to at-core-form
      if (!this._internalData) {
        this._internalData = {};
      }
      var _internalData = this._internalData;

      // update _internalData with keys from newValue
      var newValueKeys = Object.keys(newValue);
      newValueKeys.forEach(function (key, index) {
        _internalData[key] = newValue[key];
      });

      if (!_sh.isObject(this.schema) || !_sh.isObject(this.schema.properties) || Object.keys(this.schema.properties).length === 0) {
        // when schema is not set data-changed event should still be fired so that behavior is the same as when schema is set
        this._fireValueChangedEvent(this.value);
        // this means that schema is not set and at-form-complex is not initialized; return
        return;
      }

      // at this point this._internalData contains updated values for each element on the form because
      // 1) if schema was set first, this._internalData was already populated with initial values for each element,
      //    and entries from newValue are merged into this._internalData
      // 2) if value was set first, properties from this._internalData may be missing in this.value so they need to be copied over
      //    but this is done in _schemaChanged

      var fieldsContainer = Polymer.dom(this.$.insertPoint);
      var fieldElement;

      var self = this;
      // use newValueKeys here because only keys from newValue are the ones changing
      newValueKeys.forEach(function(propertyName) {
        fieldElement = self.getElement(propertyName);
        if (fieldElement) {
          fieldElement.value = newValue[propertyName];
        }
      });

      // newValue can contain only a subset of properties on the form
      // value in value-changed should contain all properties so we need to copy over missing properties from _internalData
      var internalDataKeys = Object.keys(this._internalData);
      internalDataKeys.forEach(function (key, index) {
        if (!self.value.hasOwnProperty(key)) {
          self.value[key] = self._internalData[key];
        }
      });

      this._fireValueChangedEvent(this.value);
    },
    /*
     * This function is called on value-changed event for each element on the form
     * property is property name
     * value is the new value to be set
     */
    _updateValueObject: function(property, value) {
      // this if is a guard against infinite loop that can be caused by
      // DataValidator.prototype.complexActionsAdapter.copyFieldValue
      // at-rule-engine/script/rule-engine.js line 308
      var rules = this.schema.rules;
      if (rules && rules.length > 0) {
        if (this.businessRulesEvaluationInProgress) {
          return;
        }
        this.businessRulesEvaluationInProgress = true;
        this._evaluateRules(property, value);
        this.businessRulesEvaluationInProgress = false;
      } else {
        this._internalData[property] = value;
        this.value[property] = value;
        this.validate();
        this._fireValueChangedEvent(this.value);
      }
    },

    _disabledChanged: function(newValue, oldValue) {
      var atContainer = this.$.atContainer;
      this.toggleClass('disabled', newValue, atContainer);

      var fieldsContainer = this.$.insertPoint;
      var fieldElement;
      var properties = this.schema.properties;
      var propertyNames = properties ? Object.keys(properties) : [];
      var parsedValue = schemaHelpers.parseBool(newValue);
      var self = this;

      propertyNames.forEach(function(propertyName) {
        fieldElement = self.getElement(propertyName);
        if (fieldElement) {
          fieldElement.disabled = parsedValue || schemaHelpers.parseBool(properties[propertyName].disabled);
        }
      });
    },

    _hideChanged: function(newValue, oldValue) {
      var wrapper = this.$.atContainer;
      this.toggleClass('hidden', newValue, wrapper);

      this._elementsToValidate.forEach(function (element) {
        element.hide = newValue;
      });
    },

    _internalValidStateUpdate: function (disabled, hide) {
      if (this._isReady) {
        this.validate();
      }
    },

    focus: function() {
      if (this.schema && this.schema.properties) {
        var properties = this.schema.properties;
        var propertyNames = properties ? Object.keys(properties) : [];
        if (propertyNames.length > 0) {
          var propName = propertyNames[0];
          var element = this.getElement(propName);
          if (element) {
            element.focus();
          }
        }
      }
    },

    _clearUIValidState: function() {
      var properties = this.schema.properties;
      var propertyNames = Object.keys(properties);
      var self = this;

      propertyNames.forEach(function(properyName) {
        var element = self.getElement(properyName);
        if (element && element.clearUIValidState) {
          element.clearUIValidState();
        } else if (element && element._clearUIValidState) {
          element._clearUIValidState();
        }
      });
    },

    /*
     * Validates the form
     * It calls validate method of each element in elementsToValidate array
     * Form is valid if all elements are valid. Form is invalid if at least one element is invalid.
     */
    validate: function(showError) {
      var isFunction = function(obj) {
        return Object.prototype.toString.apply(obj) === "[object Function]";
      }

      var isValid = true;
      if (showError === undefined) { showError = this.autovalidate; }

      this._elementsToValidate.forEach(function(element) {
        if (isFunction(element.validate)) {
          var elementValid = element.validate(showError);
          isValid = isValid && elementValid;
        }
      });

      return isValid;
    },

    /**
     * _layoutChanged <br/>
     * switches classes for vertical and horizontal layout
     */
    _layoutChanged: function(newValue, oldValue) {
      var fieldsContainer = this.$.insertPoint;
      if (newValue === 'horizontal') {
        this.toggleClass('horizontal', true, fieldsContainer);
        this.toggleClass('vertical', false, fieldsContainer);
      } else if (newValue === 'vertical') {
        this.toggleClass('horizontal', false, fieldsContainer);
        this.toggleClass('vertical', true, fieldsContainer);
      }
    },
    /**
     * Hides the labels for all elements on the form-complex
     */
    hideLabelsForElements: function() {
      this._iterateElements(function(element) {
        element.hideLabel = true;
      });
    },
    /**
     * Shows the labels for all elements on the form-complex
     */
    showLabelsForElements: function() {
      this._iterateElements(function(element) {
        element.hideLabel = false;
      });
    },
    /**
     * A helper function for iterating over all elements on the form-complex
     */
    _iterateElements: function(callback) {
      var fieldsContainer = Polymer.dom(this.$.insertPoint);
      var properties = this.schema.properties;

      Object.keys(properties).forEach(function(propertyName) {
        var fieldElement = fieldsContainer.querySelector('#' + propertyName);
        if (fieldElement) {
          callback(fieldElement);
        }
      });
    }
  });
</script>
