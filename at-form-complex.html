<link rel="import" href="../tangere/tangere.html">
<link rel="import" href="../at-i18n/at-i18n-behavior.html">
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="../at-elements/at-designer-elements.html">
<link rel="import" href="../at-core-schema/at-core-schema.html">

<dom-module id="at-form-complex">
  <template>
    <style include="at-form-common"></style>
    <style>
      :host * {
        box-sizing: border-box;
      }

      :host {
        @apply(--at-form-host);
      }

      .form-element {
        min-height: 84px;
      }

      .horizontal .form-element {
        min-height: 64px;
      }

    </style>
    <div id="atContainer" class="at-container">
      <label id="label">{{label}}</label>
      <template is="dom-if" if="{{label}}">
        <hr id="labelHr">
      </template>
      <div id="contentContainer" class="at-content-container">
        <div id="insertPoint"></div>
      </div>
      <div id="hint"></div>
    </div>
  </template>
</dom-module>

<script>
  "use strict";
  Polymer({
    is: 'at-form-complex',
    behaviors: [ Tangere.behaviors.i18n ],
    properties: {
      label: {
        type: String,
        value: '',
        title: 'Label'
      },
      hideLabel: {
        type: Boolean,
        value: false,
        observer: 'hideLabelChanged',
        title: 'Do not show the label'
      },
      schema: {
        type: Object,
        value: function() {
          return {
            properties: {}
          };
        },
        observer: 'schemaChanged'
      },
      value: {
        type: Object,
        value: function() {
          return {};
        },
        observer: 'valueChanged',
        title: 'Value'
      },
      valid: {
        type: Boolean,
        notify: true,
        value: true,
        readOnly: true
      },
      disabled: {
        type: Boolean,
        notify: true,
        value: false,
        observer: 'disabledChanged',
        title: 'Field value can not be changed'
      },
      /**
       * Hides the element. When hidden nothing is displayed for the element
       * @property hide
       * @type Boolean
       * @default false
       */
      hide: {
        type: Boolean,
        value: false,
        observer: 'hideChanged',
        title: 'Field is invisible'
      },
      /**
       * _layout <br>
       * added as support for rendering rows in at-form-array <br>
       * _layout = horizontal lays out elements in a horizontal line <br>
       * _layout = vertical lays out elements in a single vertical column <br>
       * @property _layout
       * @type String
       * @default vertical
       */
      _layout: {
        type: String,
        value: 'vertical',
        observer: 'layoutChanged',
        xtype: 'enum',
        xvaluelist: 'horizontal,vertical'
      }
    },
    $meta: [{
      title: "Object",
      type: "object"
    }],
    // Empty setter is here to prevent exceptions when valid is set from the outside
    // setting valid from the outside is not allowed
    set valid(value) {},
    elementsToValidate: [],
    // ------------------------------------------------------------
    // unsupported types
    // list type or xtype of the element that should not be supported by at-form-complex
    // ------------------------------------------------------------
    _unsupported_types: ["object", "array"],
    _isBatchUpdate: false,
    hideChanged: function(newValue, oldValue) {
      var wrapper = this.$.atContainer;
      this.toggleClass('hidden', newValue, wrapper);

      this.elementsToValidate.forEach(function (element) {
        element.hide = newValue;
      });

      if (this._isReady) {
        this._updateValidState();
      }
    },
    ready: function() {
      this._dataValidator = new DataValidator();
      this._isReady = true;
    },
    focus: function() {
      if (this.schema && this.schema.properties) {
        var properties = this.schema.properties;
        var propertyNames = properties ? Object.keys(properties) : [];
        if (propertyNames.length > 0) {
          var propName = propertyNames[0];
          var element = this.getElement(propName);
          if (element) {
            element.focus();
          }
        }
      }
    },
    hideLabelChanged: function(newValue, oldValue) {
      this.toggleClass("hidden", newValue, this.$.label);
      var labelHr = this.$$('#labelHr');
      this.toggleClass("hidden", newValue, labelHr);
    },
    schemaChanged: function(newValue, odlValue) {
      var self = this; // used in value-changed function closures
      var schemaHelpers = window.schemaHelpers;

      if (schemaHelpers.isString(newValue)) {
        try {
          newValue = JSON.parse(newValue);
          this.schema = newValue;
          return;
        } catch (e) {
          console.log(e);
        }
      }

      if (schemaHelpers.isString(self.value)) {
        try {
          var newData = JSON.parse(self.value);
          self.value = newData;
        } catch (e) {
          console.log(e);
        }
      }

      var fieldsContainer = this.$.insertPoint;
      var hint = this.$.hint;
      var properties = newValue.properties;
      var propertyDefinition; // definition of a single property
      var defaultValue; // holds the default value for the element
      var regularValue; // temporary holds the value from the at-form-complex.value property
      var displayType; // type of the property; translates to a coresponding element
      var fieldContainer; // at-core-form class="field" wrapper for formElement
      var fieldElement; // holds a reference to a newly created element
      var usexgridCols = false;

      this.elementsToValidate = [];

      Polymer.dom(fieldsContainer).innerHTML = '';

      Polymer.dom(hint).innerHTML = '';
      if (schemaHelpers.isNull(properties)) {
        Polymer.dom(hint).innerHTML = "Invalid schema. Schema doesn't contain a 'properties' property";
      } else {
        var propertiesJsonStr = JSON.stringify(properties);
        usexgridCols = propertiesJsonStr.indexOf("xgridcols") !== -1;
        var insertPoint = this.$.insertPoint;
        if (!usexgridCols) {
          Polymer.dom(insertPoint).classList.add('layout');
        } else {
          Polymer.dom(insertPoint).classList.remove('layout');
        }
        Object.keys(properties).forEach(function(propertyName) {
          propertyDefinition = properties[propertyName];

          displayType = schemaHelpers.getDisplayType(propertyDefinition, self._unsupported_types);
          // figure out the default value
          defaultValue = propertyDefinition.default;
          regularValue = self.value[propertyName];
          // if defaultValue exists but regular value doesn't (this.value is not set)
          if (schemaHelpers.notNullOrEmpty(defaultValue) && schemaHelpers.isNullOrEmpty(regularValue)) {
            // add defaultValue to the this.value object
            self.value[propertyName] = defaultValue;
          }

          // handle xgridcols
          var xgridcols = displayType === "section" ? 12 : 6;
          if (schemaHelpers.notNullOrEmpty(propertyDefinition.xgridcols)) {
            xgridcols = parseInt(propertyDefinition.xgridcols);
          }

          fieldContainer = document.createElement('div');
          Polymer.dom(fieldContainer).classList.add('form-element');
          var gridColsCssName = "col-" + xgridcols;
          if (!usexgridCols) {
            gridColsCssName = "flex";
          }
          Polymer.dom(fieldContainer).classList.add(gridColsCssName);

          fieldElement = schemaHelpers.createElement(propertyName, displayType, propertyDefinition);

          if (schemaHelpers.isNullOrEmpty(self.value[propertyName])) {
            // at-form-complex.value doesn't contain an entry for the current property
            // add initial value of the formElement to the at-form-complex.value
            self.value[propertyName] = fieldElement.value;
          } else {
            fieldElement.value = self.value[propertyName];
          }
          fieldElement.clearUIValidState();

          fieldElement.addEventListener('value-changed', function(event) {
            event.stopPropagation();
            if (!self._isBatchUpdate) {
              self._updateValueObject(event.target.id, event.detail.value);
            }
          });

          Polymer.dom(fieldElement).setAttribute('id', propertyName);
          self.elementsToValidate.push(fieldElement);

          // *ij* support for layout
          // if layout === horizontal new elements have hidden labels
          fieldElement.hideLabel = self._layout === 'horizontal';

          if (self.hide) {
            fieldElement.hide = true;
          }

          // append paper element to its container
          Polymer.dom(fieldContainer).appendChild(fieldElement);
          // add container to as child to insertPoint
          Polymer.dom(fieldsContainer).appendChild(fieldContainer);

          // udpate the disabled status
        });

        this.disabledChanged(this.disabled, undefined);
        this._updateValidState();
      }
    },

    /* *ij*
     OK. Imperative data binding doesn't work in polymer anymore.
     It may happen in the future but not in near future.
     Using at-core-form.data[field] = 'newValue' doesn't work. Its not possible to bind to at-core-form.data[field] to update field value automatically
     Explained in https://github.com/Polymer/polymer/issues/1778 and https://github.com/Polymer/polymer/issues/1796

     So, to solve this shortcoming a updateFormElementValue function is introduced
     The purpose of this function is, obviously, to update a value of the specific field.
     This function will update the .data object and .value of the field with provided elementId.
     If the field with provided elementId doesn't exist a debug message will be loged in the console

     Alternative to this approach is to create a completely new object each time you want to update the .data property
     IMO, this approach is a waste of time. An updateFormElementValue function is much more efficient

     Another alternative to this approach is to have a function that will return the element itself. Than the client can do whatever he likes with the element
     not just update value. This approach seems reasonable for setFieldState action in at-form-rule-edit
     */
    updateFormElementValue: function(elementId, value) {
      var fieldsContainer = this.$.insertPoint;
      var fieldElement = Polymer.dom(fieldsContainer).querySelector('#' + elementId);

      this.value[elementId] = value;
      if (schemaHelpers.valueNotReadOnly(fieldElement)) {
        fieldElement.value = value;
      } else {
        // if not log the debug message
        console.debug('Field with id: ' + elementId + ' doesn\'t exist in form.');
      }
    },

    setElementState: function(elementId, state, value) {
      var fieldsContainer = this.$.insertPoint;
      var fieldElement = Polymer.dom(fieldsContainer).querySelector('#' + elementId);

      if (fieldElement) {
        fieldElement[state] = value;
      } else {
        // if not log the debug message
        console.debug('Field with id: ' + elementId + ' doesn\'t exist in form.');
      }
    },

    getElement: function(elementId) {
      var fieldsContainer = this.$.insertPoint;
      var selector = '#' + elementId;
      var fieldElement = Polymer.dom(fieldsContainer).querySelector(selector);
      return fieldElement;
    },

    valueChanged: function(newValue, oldValue) {
      var fieldsContainer = Polymer.dom(this.$.insertPoint);
      var fieldElement;

      if (Object.prototype.toString.call(newValue) === "[object String]") {
        try {
          newValue = JSON.parse(newValue);
          this.value = newValue;
          return;
        } catch (e) {
          console.log(e);
        }
      }

      this._isBatchUpdate = true;
      // *ij* it can happen that new value doesn't set new value for all elements
      // values for elements that are not set should be preserved
      if (schemaHelpers.isObject(oldValue)) {
        Object.keys(oldValue).forEach(function(propertyName) {
          if (!newValue.hasOwnProperty(propertyName)) {
            newValue[propertyName] = oldValue[propertyName];
          }
        });
      }

      if (schemaHelpers.isObject(newValue)) {
        Object.keys(newValue).forEach(function(propertyName) {
          fieldElement = fieldsContainer.querySelector('#' + propertyName);
          if (schemaHelpers.valueNotReadOnly(fieldElement)) {
            fieldElement.value = newValue[propertyName];
          }
        });
      } else {
        console.log('at-form-complex expects objects as new value, but got ' + schemaHelpers.formatJson(newValue) + ' instead');
      }

      this._isBatchUpdate = false;

      this._updateValidState();

      this.fire('value-changed', {
        value: this.value
      });
    },
    /*
     * This function is called on value-changed event for each element on the form
     * property is property name
     * value is the new value to be set
     */
    _updateValueObject: function(property, value) {
      // this if is a guard against infinite loop that can be caused by
      // DataValidator.prototype.complexActionsAdapter.copyFieldValue
      // at-rule-engine/script/rule-engine.js line 308
      if (this.schema.rules) {
        if (!this.businessRulesEvaluationInProgress) {
          this.businessRulesEvaluationInProgress = true;
          var complexUserValue = {};
          schemaHelpers.copyProperties(Object.keys(this.value), [], this.value, complexUserValue);
          complexUserValue[property] = value;
          var complexBusinessValue = this._dataValidator.validateComplexValue(complexUserValue, this.schema.rules, this);
          var self = this;

          var complexUserValueJson = JSON.stringify(complexUserValue);
          var complexBusinessValueJson = JSON.stringify(complexBusinessValue);
          if (complexUserValueJson !== complexBusinessValueJson) {
            // update form element's value because of R3
            var bv_propertyNames = Object.keys(complexBusinessValue);
            bv_propertyNames.forEach(function(bv_propertyName, index) {
              var cuvPropValue = complexUserValue[bv_propertyName];
              var cbvPropValue = complexBusinessValue[bv_propertyName];
              if (cuvPropValue !== cbvPropValue) {
                self.value[bv_propertyName] = cbvPropValue;
                self.updateFormElementValue(bv_propertyName, cbvPropValue);
              } else {
                self.value[bv_propertyName] = cuvPropValue;
                self.updateFormElementValue(bv_propertyName, cuvPropValue);
              }
            });

            // trigger value-changed because of R4
            this.fire('value-changed', {
              value: this.value
            });
          } else {
            this.value[property] = value;
            this._updateValidState();
            this.fire('value-changed', {
              value: this.value
            });
          }
          this.businessRulesEvaluationInProgress = false;
        } else {
          return;
        }
      } else {
        this.value[property] = value;
        this._updateValidState();
        this.fire('value-changed', {
          value: this.value
        });
      }
    },

    clearUIValidState: function() {
      var properties = this.schema.properties;
      var propertyNames = Object.keys(properties);
      var self = this;

      propertyNames.forEach(function(properyName) {
        var element = self.getElement(properyName);
        if (element) {
          element.clearUIValidState();
        }
      });
    },

    _updateValidState: function() {
      var isValid = true;

      this.elementsToValidate.forEach(function(element) {
        isValid = isValid && element.valid;
      });

      this._setValid(isValid);
    },

    /*
     * Validates the form
     * It calls validate method of each element in elementsToValidate array
     * Form is valid if all elements are valid. Form is invalid if at least one element is invalid.
     */
    validate: function() {
      var isFunction = function(obj) {
        return Object.prototype.toString.apply(obj) === "[object Function]";
      }
      var isValid = true;

      this.elementsToValidate.forEach(function(element) {
        if (isFunction(element.validate)) {
          var elementValid = element.validate();
          isValid = isValid && elementValid;
        }
      });

      this._setValid(isValid);

      return isValid;
    },

    disabledChanged: function(newValue, oldValue) {
      var atContainer = this.$.atContainer;
      this.toggleClass('disabled', newValue, atContainer);

      var fieldsContainer = this.$.insertPoint;
      var fieldElement;
      var properties = this.schema.properties;

      Object.keys(properties).forEach(function(propertyName) {
        fieldElement = Polymer.dom(fieldsContainer).querySelector('#' + propertyName);
        if (fieldElement) {
          if (newValue) {
            fieldElement.disabled = newValue;
          } else {
            fieldElement.disabled = Boolean(properties[propertyName].disabled);
          }
        }
      });

      if (this._isReady) {
        this._updateValidState();
      }
    },
    /**
     * layoutChanged <br/>
     * switches classes for vertical and horizontal layout
     */
    layoutChanged: function(newValue, oldValue) {
      var fieldsContainer = this.$.insertPoint;
      if (newValue === 'horizontal') {
        this.toggleClass('horizontal', true, fieldsContainer);
        this.toggleClass('vertical', false, fieldsContainer);
      } else if (newValue === 'vertical') {
        this.toggleClass('horizontal', false, fieldsContainer);
        this.toggleClass('vertical', true, fieldsContainer);
      }
    },
    /**
     * Hides the labels for all elements on the form-complex
     */
    hideLabelsForElements: function() {
      this._iterateElements(function(element) {
        element.hideLabel = true;
      });
    },
    /**
     * Shows the labels for all elements on the form-complex
     */
    showLabelsForElements: function() {
      this._iterateElements(function(element) {
        element.hideLabel = false;
      });
    },
    /**
     * A helper function for iterating over all elements on the form-complex
     */
    _iterateElements: function(callback) {
      var fieldsContainer = this.$.insertPoint;
      var properties = this.schema.properties;

      Object.keys(properties).forEach(function(propertyName) {
        var fieldElement = Polymer.dom(fieldsContainer).querySelector('#' + propertyName);
        if (fieldElement) {
          callback(fieldElement);
        }
      });
    }
  });
</script>
